#!/usr/bin/env python
# coding: utf-8


# 问题：
# 1- MOV 等可以接受多个不同来源类型操作数的指令，如何在机器码层面进行区分
# 2- 在尝试将指令转成机器码时，遇到 循环引用 的问题，
#    即：不知道怎样用最小的元方法来实现其他方法。
#    举例：实现 INIT 时，用到了 MOV SP -1 来初始化栈，
#         但是这里就涉及到必须先实现 MOV，则又回到了问题-1...

registers = {
    'RA': 'A 寄存器',
    'RB': 'B 寄存器',
    'RC': 'C 寄存器',
    'RD': 'D 寄存器',
    'SP': '栈指针',
    'IP': '指令指针',
    'ZF': '0位标志',
    'SF': '符号标志',
    'OF': '溢出标志',
    'TF': '类型标志',
}

commands = {
    'INIT': '进入程序，初始化操作',
    'HALT': '结束',
    'CMP':  '比较',
    'JMP':  '跳转',
    'RTN':  '返回',
    'LOOP': '循环',
    'WAIT': '等待',
    'MOV':  '栈TO寄存器/寄存器TO寄存器/直接数TO寄存器',
    'PUSH': '任意寄存器/直接数入栈',
    'POP':  '出栈，值放入到寄存器A',
    'ADD':  '任意直接数/寄存器 + 任意直接数/寄存器，结果存入寄存器B',
    'SUB':  '任意直接数/寄存器 - 任意直接数/寄存器，结果存入寄存器B',
    'MLT':  '任意直接数/寄存器 * 任意直接数/寄存器，结果存入寄存器B',
    'DVI':  '任意直接数/寄存器 / 任意直接数/寄存器，结果存入寄存器B',
    'AND':  '任意直接数/寄存器 & 任意直接数/寄存器，结果存入寄存器B',
    'OR':   '任意直接数/寄存器 | 任意直接数/寄存器，结果存入寄存器B',
    'NOT':  '! 任意直接数/寄存器，结果存入寄存器B',
    'LEFT': '任意直接数/寄存器左移，结果存入寄存器B',
    'RHTL': '任意直接数/寄存器逻辑右移，结果存入寄存器B',
    'RHTN': '任意直接数/寄存器算数右移，结果存入寄存器B',
}

registers_mc = {
    'RA': 0B00000000,
    'RB': 0B00000001,
    'RC': 0B00000010,
    'RD': 0B00000011,
    'SP': 0B00000100,
    'IP': 0B00000101,
    'ZF': 0B00000110,
    'SF': 0B00000111,
    'OF': 0B00001000,
    'TF': 0B00001001,
}

commands_mc = {
    'INIT': 0B00000000,
    'HALT': 0B00000001,
    'CMP':  0B00000010,
    'JMP':  0B00000011,
    'RTN':  0B00000100,
    'LOOP': 0B00000101,
    'WAIT': 0B00000110,
    'MOV':  0B00000111,
    'PUSH': 0B00001000,
    'POP':  0B00001001,
    'ADD':  0B00001010,
    'SUB':  0B00001011,
    'MLT':  0B00001100,
    'DVI':  0B00001101,
    'AND':  0B00001110,
    'OR':   0B00001111,
    'NOT':  0B00010001,
    'LEFT': 0B00010010,
    'RHTL': 0B00010011,
    'RHTN': 0B00010100,
}

asm_prog = '''
INIT
MOV D 10
MOV C 20
ADD
MOV A B
LEFT A 2
PUSH B
HLT
'''

asm_mc = '''
# INIT
0B00000000
# MOV      D          10
0B00000111 0B00000011 0B00001010
# MOV      C          20
0B00000111 0B00000010 0B00010100
# ADD
0B00001010
# MOV      A          B
0B00000111 0B00000000 0B00000001
# LEFT     A          2
0B00010010 0B00000000 0B00000010
# PUSH     B
0B00001000 0B00000001
# HLT
0B00000001
'''
